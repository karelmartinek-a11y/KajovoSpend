diff --git a/src/kajovospend/service/processor.py b/src/kajovospend/service/processor.py
index e8a4fe6..c3b9b5a 100644
--- a/src/kajovospend/service/processor.py
+++ b/src/kajovospend/service/processor.py
@@ -54,49 +54,165 @@ class Processor:
             self.log.warning(f"OCR init failed; will quarantine documents. Error: {e}")
             self.ocr_engine = None
 
     def _ocr_pdf_pages(self, pdf_path: Path, status_cb=None) -> Tuple[List[str], List[float], int]:
         """
-        Vrátí OCR text po jednotlivých stránkách:
-        - embedded text: per page extract_text()
-        - jinak: render->OCR per page
+        Per-page hybrid:
+        - pro každou stránku: zkus embedded extract_text() -> ohodnoť kvalitu textu
+        - když embedded nedává smysl: render+OCR jen pro danou stránku
+        - výsledný page_text = lepší z embedded/OCR (řeší mixované PDF)
         """
-        # Try embedded text first (page-by-page)
-        if status_cb:
-            status_cb("PDF: čtu text (bez OCR)…")
-        try:
-            reader = PdfReader(str(pdf_path))
-            texts: List[str] = []
-            for page in reader.pages:
-                t = page.extract_text() or ""
-                texts.append(t)
-            # if at least one page has real text, treat as embedded text mode
-            if any((t or "").strip() for t in texts):
-                confs = [0.95 if (t or "").strip() else 0.0 for t in texts]
-                return texts, confs, len(texts)
-        except Exception:
-            pass
-
-        # fallback to image OCR
-        if self.ocr_engine is None:
-            return [], [], 0
-        dpi_cfg = int(self.cfg["ocr"].get("pdf_dpi", 200))
-        dpi = max(300, dpi_cfg)
-        if status_cb:
-            status_cb(f"PDF: render na obrázky ({dpi} DPI)…")
-        images = render_pdf_to_images(pdf_path, dpi=dpi)
-        texts2: List[str] = []
-        confs2: List[float] = []
-        for idx_page, img in enumerate(images, start=1):
-            if status_cb:
-                status_cb(f"OCR: strana {idx_page}/{len(images)}…")
-            t, c = self.ocr_engine.image_to_text(img)
-            texts2.append(t or "")
-            confs2.append(float(c or 0.0))
-        return texts2, confs2, len(images)
+        ocr_cfg = (self.cfg.get("ocr") or {}) if isinstance(self.cfg, dict) else {}
+        # hranice pro rozhodování "embedded je použitelné"
+        quality_threshold = float(ocr_cfg.get("page_text_quality_threshold", 0.45))
+        min_non_ws = int(ocr_cfg.get("page_text_min_non_ws", 25))
+        score_margin = float(ocr_cfg.get("page_text_score_margin", 0.02))
+
+        def _metrics(txt: str) -> Dict[str, Any]:
+            t = txt or ""
+            total = len(t)
+            non_ws = len(re.sub(r"\s+", "", t))
+            letters = len(re.findall(r"[A-Za-zÁČĎÉĚÍŇÓŘŠŤÚŮÝŽáčďéěíňóřšťúůýž]", t))
+            digits = len(re.findall(r"\d", t))
+            # replacement char + control chars (mimo whitespace) => typicky šum / rozbité dekódování
+            bad = t.count("\ufffd") + len(re.findall(r"[\x00-\x08\x0b\x0c\x0e-\x1f]", t))
+            lines_nonempty = len([ln for ln in t.splitlines() if ln.strip()])
+            return {
+                "total": total,
+                "non_ws": non_ws,
+                "letters": letters,
+                "digits": digits,
+                "bad": bad,
+                "lines_nonempty": lines_nonempty,
+            }
+
+        def _score(m: Dict[str, Any]) -> float:
+            total = int(m.get("total") or 0)
+            non_ws = int(m.get("non_ws") or 0)
+            if non_ws <= 0 or total <= 0:
+                return 0.0
+            letters = int(m.get("letters") or 0)
+            digits = int(m.get("digits") or 0)
+            bad = int(m.get("bad") or 0)
+            # dostatek textu (cap) + podíl "rozumných" znaků (alnum) - penalizace šumu
+            density = min(1.0, non_ws / 400.0)
+            alnum_ratio = (letters + digits) / max(1, non_ws)
+            bad_ratio = bad / max(1, total)
+            s = 0.55 * density + 0.55 * alnum_ratio - 0.80 * bad_ratio
+            if s < 0.0:
+                return 0.0
+            if s > 1.0:
+                return 1.0
+            return float(s)
+
+        def _conf_from_embedded(m: Dict[str, Any], s: float) -> float:
+            # embedded nemá "OCR confidence", ale potřebujeme číslo pro downstream review logiku
+            non_ws = int(m.get("non_ws") or 0)
+            if non_ws <= 0:
+                return 0.0
+            # map score -> (0.50..0.95), clamp
+            conf = 0.50 + 0.45 * float(s)
+            if conf < 0.0:
+                conf = 0.0
+            if conf > 0.95:
+                conf = 0.95
+            return float(conf)
+
+        if status_cb:
+            status_cb("PDF: čtu text (hybrid embedded/OCR)…")
+
+        # 1) embedded text per page
+        try:
+            reader = PdfReader(str(pdf_path))
+            embedded_texts: List[str] = []
+            embedded_metrics: List[Dict[str, Any]] = []
+            embedded_scores: List[float] = []
+            for page in reader.pages:
+                t = page.extract_text() or ""
+                embedded_texts.append(t)
+                m = _metrics(t)
+                embedded_metrics.append(m)
+                embedded_scores.append(_score(m))
+            n_pages = len(embedded_texts)
+        except Exception as e:
+            self.log.warning(f"PDF embedded extract_text() failed; fallback to OCR. Error: {e}")
+            embedded_texts = []
+            embedded_metrics = []
+            embedded_scores = []
+            n_pages = 0
+
+        # když embedded selže a nemáme OCR, není co dělat
+        if n_pages <= 0 and self.ocr_engine is None:
+            return [], [], 0
+
+        # 2) rozhodnutí, které stránky OCRovat
+        needs_ocr: List[bool] = []
+        if n_pages > 0:
+            for i in range(n_pages):
+                m = embedded_metrics[i]
+                s = embedded_scores[i]
+                # embedded je "slabé", když je málo textu nebo skóre pod prahem
+                weak = (int(m.get("non_ws") or 0) < min_non_ws) or (float(s) < quality_threshold)
+                needs_ocr.append(bool(weak))
+        else:
+            # nevíme počet stran přes PdfReader, ale OCR pipeline ho zjistí přes render
+            needs_ocr = []
+
+        # připrav výsledek jako embedded (kde existuje)
+        out_texts: List[str] = list(embedded_texts) if embedded_texts else []
+        out_confs: List[float] = []
+        if embedded_texts:
+            for i in range(n_pages):
+                out_confs.append(_conf_from_embedded(embedded_metrics[i], embedded_scores[i]))
+
+        # summary log: kolik stránek je weak
+        if embedded_texts:
+            weak_cnt = sum(1 for x in needs_ocr if x)
+            self.log.info(
+                f"pdf_text_source: pages={n_pages} weak_pages={weak_cnt} "
+                f"threshold={quality_threshold:.2f} min_non_ws={min_non_ws}"
+            )
+
+        # 3) pokud nemáme OCR engine, vrať embedded (i když je slabé)
+        if self.ocr_engine is None:
+            if embedded_texts:
+                # log per page (bez OCR hodnot)
+                for i in range(n_pages):
+                    m = embedded_metrics[i]
+                    s = embedded_scores[i]
+                    chosen = "embedded"
+                    why = "weak_embedded_but_no_ocr" if needs_ocr[i] else "embedded_ok"
+                    self.log.info(
+                        f"pdf_text_source page={i+1}/{n_pages} chosen={chosen} why={why} "
+                        f"emb_score={s:.3f} emb_nonws={int(m.get('non_ws') or 0)} emb_bad={int(m.get('bad') or 0)}"
+                    )
+                return out_texts, out_confs, n_pages
+            return [], [], 0
+
+        # 4) OCR jen pro stránky, kde embedded nedává smysl; pak vyber lepší z embedded/OCR
+        dpi_cfg = int(self.cfg["ocr"].get("pdf_dpi", 200))
+        dpi = max(300, dpi_cfg)
+
+        # pokud embedded vůbec není (např. PdfReader fail), OCRujeme celý PDF (po stránkách) a hotovo
+        if not embedded_texts:
+            if status_cb:
+                status_cb(f"PDF: render na obrázky ({dpi} DPI)…")
+            images = render_pdf_to_images(pdf_path, dpi=dpi)
+            texts2: List[str] = []
+            confs2: List[float] = []
+            for idx_page, img in enumerate(images, start=1):
+                if status_cb:
+                    status_cb(f"OCR: strana {idx_page}/{len(images)}…")
+                t, c = self.ocr_engine.image_to_text(img)
+                texts2.append(t or "")
+                confs2.append(float(c or 0.0))
+                m = _metrics(t or "")
+                s = _score(m)
+                self.log.info(
+                    f"pdf_text_source page={idx_page}/{len(images)} chosen=ocr why=no_embedded "
+                    f"ocr_score={s:.3f} ocr_nonws={int(m.get('non_ws') or 0)} ocr_bad={int(m.get('bad') or 0)} "
+                    f"ocr_conf={float(c or 0.0):.3f}"
+                )
+            return texts2, confs2, len(images)
+
+        # máme embedded -> OCR jen pro vybrané stránky (seskupené do souvislých úseků kvůli renderu)
+        need_idxs = [i for i, need in enumerate(needs_ocr) if need]
+        if not need_idxs:
+            # vše OK, čistě embedded
+            for i in range(n_pages):
+                m = embedded_metrics[i]
+                s = embedded_scores[i]
+                self.log.info(
+                    f"pdf_text_source page={i+1}/{n_pages} chosen=embedded why=embedded_ok "
+                    f"emb_score={s:.3f} emb_nonws={int(m.get('non_ws') or 0)} emb_bad={int(m.get('bad') or 0)}"
+                )
+            return out_texts, out_confs, n_pages
+
+        segments: List[Tuple[int, int]] = []
+        seg_start = need_idxs[0]
+        seg_prev = need_idxs[0]
+        for idx in need_idxs[1:]:
+            if idx == seg_prev + 1:
+                seg_prev = idx
+                continue
+            segments.append((seg_start, seg_prev))
+            seg_start = idx
+            seg_prev = idx
+        segments.append((seg_start, seg_prev))
+
+        for s0, s1 in segments:
+            count = (s1 - s0 + 1)
+            if status_cb:
+                status_cb(f"PDF: OCR strany {s0+1}-{s1+1}/{n_pages}…")
+            images = render_pdf_to_images(pdf_path, dpi=dpi, start_page=s0, max_pages=count)
+            for off, img in enumerate(images):
+                page_idx = s0 + off
+                if status_cb:
+                    status_cb(f"OCR: strana {page_idx+1}/{n_pages}…")
+                ocr_text, ocr_conf = self.ocr_engine.image_to_text(img)
+                ocr_text = ocr_text or ""
+                ocr_conf_f = float(ocr_conf or 0.0)
+
+                emb_m = embedded_metrics[page_idx]
+                emb_s = embedded_scores[page_idx]
+                ocr_m = _metrics(ocr_text)
+                ocr_s = _score(ocr_m)
+
+                # vyber lepší text (default: embedded, OCR jen když je prokazatelně lepší)
+                choose_ocr = bool(ocr_s > (emb_s + score_margin))
+                if choose_ocr:
+                    out_texts[page_idx] = ocr_text
+                    out_confs[page_idx] = ocr_conf_f
+                    chosen = "ocr"
+                    why = "embedded_weak_or_worse"
+                else:
+                    chosen = "embedded"
+                    why = "ocr_not_better"
+
+                self.log.info(
+                    f"pdf_text_source page={page_idx+1}/{n_pages} chosen={chosen} why={why} "
+                    f"emb_score={emb_s:.3f} emb_nonws={int(emb_m.get('non_ws') or 0)} emb_bad={int(emb_m.get('bad') or 0)} "
+                    f"ocr_score={ocr_s:.3f} ocr_nonws={int(ocr_m.get('non_ws') or 0)} ocr_bad={int(ocr_m.get('bad') or 0)} "
+                    f"ocr_conf={ocr_conf_f:.3f}"
+                )
+
+        return out_texts, out_confs, n_pages
 
     def _merge_extracted_by_key(self, per_page: List[Tuple[int, Any, str, float]]) -> List[Dict[str, Any]]:
         """
         per_page: [(page_no, Extracted, full_text, ocr_conf), ...]
         Sloučí sousední stránky do 1 dokladu, pokud sedí klíč:
           (supplier_ico, doc_number, issue_date)
         Když klíč není kompletní, neslučuje (bezpečnější deterministické chování).
         """
